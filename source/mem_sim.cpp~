#include "libs.h"
#include "mem_sim_classes.hpp"
#include "mem_sim_functions.hpp"
using namespace std;

int main(int argc, const char * argv[]){
	if( argc < 8 ){
		cout << "Less than 8 inputs." << endl;
		exit( EXIT_FAILURE );
	}
	
	Parameters P = Parameters(argv);
	string input;
	map <long, string> cacheData;
	vector<list<Block>> cacheVect(P.setPerCache);
	
	while(getline(cin, input)) {
		string buffer;
		string outputString;
		unsigned address;
		string data;
		istringstream sstr(input);
		sstr >> buffer;
		if (buffer == "flush-req") {
			int accessTime = 0;
			SOUT("FLUSH");
			for (vector<list<Block>>::iterator v_it = cacheVect.begin() ; v_it != cacheVect.end(); ++v_it) {
				for(list<Block>::iterator l_it = v_it->begin(); l_it != v_it->end(); ++l_it) {
					if(l_it->dirtyBit == 1) {
			 			accessTime += P.writeTime;
						l_it->dirtyBit = 0;
					}
				}
			}

			stringstream ss;
			ss << "flush-ack " << accessTime << endl;
			outputString = ss.str();
		} else if (buffer == "debug-req") {
			SOUT("DEBUG");
			stringstream ss;
			ss << "debug-ack-begin" << endl;
			for (vector<list<Block>>::iterator v_it = cacheVect.begin() ; v_it != cacheVect.end(); ++v_it) {
				ss << "Set " << v_it - cacheVect.begin() << ":" << endl << endl;
				bool empty = true;
				for(list<Block>::iterator l_it = v_it->begin(); l_it != v_it->end(); ++l_it) {
					empty = false;
					ss << *l_it << endl;
				}
				if (empty == true) {
					ss << "EMPTY" << endl;
				}
			}
			ss << "debug-ack-end" << endl;
			outputString = ss.str();
		} else if (buffer == "read-req") { 
			SOUT("READ");
			sstr >> address;
			outputString = readOrWrite(cacheData,cacheVect,P,address,0);
        } else if (buffer == "write-req") {
        	SOUT("WRITE");
        	sstr >> address >> data;
        	cacheData[address] = data;
        	outputString = readOrWrite(cacheData,cacheVect,P,address,1);
        } 
        else { 
        	SOUT("NOTHING");
        }
        cout << outputString;
	}

}


